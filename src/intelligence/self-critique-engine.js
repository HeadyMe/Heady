// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë  ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó                     ‚ïë
// ‚ïë  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù                     ‚ïë
// ‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù                      ‚ïë
// ‚ïë  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë  ‚ïö‚ñà‚ñà‚ïî‚ïù                       ‚ïë
// ‚ïë  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ïë                        ‚ïë
// ‚ïë  ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïù                        ‚ïë
// ‚ïë                                                                  ‚ïë
// ‚ïë  ‚àû SACRED GEOMETRY ‚àû  Heady Systems - HCFP Full Auto Mode        ‚ïë
// ‚ïë  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ  ‚ïë
// ‚ïë  FILE: self-critique-engine.js                               ‚ïë
// ‚ïë  UPDATED: 20260219-220000                                            ‚ïë
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

/**
 * üß† Self-Critique Engine
 * 
 * Continuous self-improvement through pattern analysis, performance evaluation,
 * and adaptive strategy optimization for intelligent, self-aware systems
 */

const fs = require('fs');
const path = require('path');
const { EventEmitter } = require('events');
const { HCAiRouter } = require('../ai-router/hc-ai-router-simple');

class SelfCritiqueEngine extends EventEmitter {
  constructor(config = {}) {
    super();
    
    this.config = {
      critique_interval_hours: config.critique_interval_hours || 6,
      analysis_window_hours: config.analysis_window_hours || 24,
      min_data_points: config.min_data_points || 10,
      learning_rate: config.learning_rate || 0.1,
      adaptation_threshold: config.adaptation_threshold || 0.8,
      ...config
    };
    
    // Initialize AI Router for intelligent self-analysis
    this.aiRouter = new HCAiRouter();
    this.nodeId = 'self-critique-engine';
    
    // Self-awareness data
    this.performanceHistory = [];
    this.decisionHistory = [];
    this.adaptationHistory = [];
    this.patternLibrary = new Map();
    this.strategyEffectiveness = new Map();
    
    // Current self-model
    this.selfModel = {
      strengths: [],
      weaknesses: [],
      opportunities: [],
      threats: [],
      capabilities: new Map(),
      limitations: new Map(),
      learning_progress: 0
    };
    
    // AI router integration
    this.aiRouter = null;
    
    // Timers
    this.critiqueTimer = null;
    this.patternAnalysisTimer = null;
    
    console.log('[Self-Critique] Engine initialized');
  }

  /**
   * üöÄ Start the self-critique engine
   */
  async start(aiRouter = null) {
    if (this.critiqueTimer) {
      console.log('[Self-Critique] Already running');
      return;
    }
    
    this.aiRouter = aiRouter;
    
    console.log('\nüß† STARTING SELF-CRITIQUE ENGINE');
    console.log('='.repeat(50));
    
    try {
      // Load historical data
      await this.loadHistoricalData();
      
      // Initialize self-model
      await this.initializeSelfModel();
      
      // Start periodic critique
      this.startPeriodicCritique();
      
      // Start pattern analysis
      this.startPatternAnalysis();
      
      console.log('‚úÖ Self-Critique Engine started');
      this.emit('started');
      
    } catch (error) {
      console.error('‚ùå Failed to start Self-Critique Engine:', error);
      this.emit('error', error);
      throw error;
    }
  }

  /**
   * üõë Stop the self-critique engine
   */
  async stop() {
    if (this.critiqueTimer) {
      clearInterval(this.critiqueTimer);
      this.critiqueTimer = null;
    }
    
    if (this.patternAnalysisTimer) {
      clearInterval(this.patternAnalysisTimer);
      this.patternAnalysisTimer = null;
    }
    
    console.log('[Self-Critique] Engine stopped');
    this.emit('stopped');
  }

  /**
   * üìä Record performance data
   */
  recordPerformance(data) {
    const performanceEntry = {
      timestamp: new Date(),
      ors: data.ors,
      task_success_rate: data.task_success_rate,
      avg_response_time: data.avg_response_time,
      resource_utilization: data.resource_utilization,
      error_rate: data.error_rate,
      throughput: data.throughput,
      user_satisfaction: data.user_satisfaction,
      cost_efficiency: data.cost_efficiency,
      ...data
    };
    
    this.performanceHistory.push(performanceEntry);
    
    // Keep only recent history
    const cutoff = new Date(Date.now() - (this.config.analysis_window_hours * 60 * 60 * 1000));
    this.performanceHistory = this.performanceHistory.filter(entry => entry.timestamp > cutoff);
    
    this.emit('performance_recorded', performanceEntry);
  }

  /**
   * üéØ Record decision data
   */
  recordDecision(data) {
    const decisionEntry = {
      timestamp: new Date(),
      context: data.context,
      decision: data.decision,
      reasoning: data.reasoning,
      expected_outcome: data.expected_outcome,
      actual_outcome: data.actual_outcome,
      confidence: data.confidence,
      success: data.success,
      ...data
    };
    
    this.decisionHistory.push(decisionEntry);
    
    // Keep only recent history
    const cutoff = new Date(Date.now() - (this.config.analysis_window_hours * 60 * 60 * 1000));
    this.decisionHistory = this.decisionHistory.filter(entry => entry.timestamp > cutoff);
    
    this.emit('decision_recorded', decisionEntry);
  }

  /**
   * üîÑ Record adaptation data
   */
  recordAdaptation(data) {
    const adaptationEntry = {
      timestamp: new Date(),
      trigger: data.trigger,
      adaptation: data.adaptation,
      expected_improvement: data.expected_improvement,
      actual_improvement: data.actual_improvement,
      success: data.success,
      side_effects: data.side_effects,
      ...data
    };
    
    this.adaptationHistory.push(adaptationEntry);
    
    // Keep only recent history
    const cutoff = new Date(Date.now() - (this.config.analysis_window_hours * 60 * 60 * 1000));
    this.adaptationHistory = this.adaptationHistory.filter(entry => entry.timestamp > cutoff);
    
    this.emit('adaptation_recorded', adaptationEntry);
  }

  /**
   * üß† Perform comprehensive self-critique
   */
  async performSelfCritique() {
    console.log('\nüß† PERFORMING SELF-CRITIQUE');
    console.log('='.repeat(40));
    
    try {
      const critique = {
        timestamp: new Date(),
        performance_analysis: await this.analyzePerformance(),
        decision_analysis: await this.analyzeDecisions(),
        adaptation_analysis: await this.analyzeAdaptations(),
        pattern_analysis: await this.analyzePatterns(),
        capability_assessment: await this.assessCapabilities(),
        swot_analysis: await this.performSWOTAnalysis(),
        recommendations: await this.generateRecommendations(),
        learning_insights: await this.extractLearningInsights()
      };
      
      // Update self-model
      await this.updateSelfModel(critique);
      
      // Store critique
      await this.storeCritique(critique);
      
      // Apply immediate improvements
      await this.applyImmediateImprovements(critique.recommendations);
      
      this.emit('critique_completed', critique);
      console.log('‚úÖ Self-critique completed');
      
      return critique;
      
    } catch (error) {
      console.error('‚ùå Self-critique failed:', error);
      this.emit('critique_failed', error);
      throw error;
    }
  }

  /**
   * üìà Analyze performance trends
   */
  async analyzePerformance() {
    if (this.performanceHistory.length < this.config.min_data_points) {
      return { status: 'insufficient_data', message: 'Need more performance data' };
    }
    
    const recent = this.performanceHistory.slice(-20);
    const older = this.performanceHistory.slice(-40, -20);
    
    const analysis = {
      trends: this.calculateTrends(recent, older),
      anomalies: this.detectAnomalies(recent),
      correlations: this.findCorrelations(recent),
      efficiency_metrics: this.calculateEfficiencyMetrics(recent),
      health_indicators: this.calculateHealthIndicators(recent)
    };
    
    return analysis;
  }

  /**
   * üéØ Analyze decision quality
   */
  async analyzeDecisions() {
    if (this.decisionHistory.length < this.config.min_data_points) {
      return { status: 'insufficient_data', message: 'Need more decision data' };
    }
    
    const recent = this.decisionHistory.slice(-50);
    
    const analysis = {
      success_rate: recent.filter(d => d.success).length / recent.length,
      confidence_accuracy: this.calculateConfidenceAccuracy(recent),
      decision_patterns: this.identifyDecisionPatterns(recent),
      context_sensitivity: this.analyzeContextSensitivity(recent),
      outcome_prediction_accuracy: this.calculatePredictionAccuracy(recent),
      improvement_areas: this.identifyDecisionImprovementAreas(recent)
    };
    
    return analysis;
  }

  /**
   * üîÑ Analyze adaptation effectiveness
   */
  async analyzeAdaptations() {
    if (this.adaptationHistory.length < 5) {
      return { status: 'insufficient_data', message: 'Need more adaptation data' };
    }
    
    const recent = this.adaptationHistory.slice(-20);
    
    const analysis = {
      success_rate: recent.filter(a => a.success).length / recent.length,
      improvement_magnitude: this.calculateImprovementMagnitude(recent),
      side_effect_frequency: this.calculateSideEffectFrequency(recent),
      adaptation_patterns: this.identifyAdaptationPatterns(recent),
      trigger_effectiveness: this.analyzeTriggerEffectiveness(recent),
      learning_velocity: this.calculateLearningVelocity(recent)
    };
    
    return analysis;
  }

  /**
   * üîç Analyze patterns in behavior
   */
  async analyzePatterns() {
    const patterns = {
      performance_patterns: this.findPerformancePatterns(),
      decision_patterns: this.findDecisionPatterns(),
      temporal_patterns: this.findTemporalPatterns(),
      contextual_patterns: this.findContextualPatterns(),
      resource_patterns: this.findResourcePatterns(),
      error_patterns: this.findErrorPatterns()
    };
    
    // Update pattern library
    for (const [type, typePatterns] of Object.entries(patterns)) {
      if (!this.patternLibrary.has(type)) {
        this.patternLibrary.set(type, []);
      }
      
      const library = this.patternLibrary.get(type);
      for (const pattern of typePatterns) {
        const existing = library.find(p => p.signature === pattern.signature);
        if (existing) {
          existing.frequency++;
          existing.confidence = Math.min(1, existing.confidence + 0.1);
        } else {
          library.push({ ...pattern, frequency: 1, confidence: 0.5 });
        }
      }
    }
    
    return patterns;
  }

  /**
   * üéØ Assess current capabilities
   */
  async assessCapabilities() {
    const capabilities = new Map();
    
    // Performance capabilities
    capabilities.set('performance', {
      current_level: this.assessPerformanceCapability(),
      potential: this.assessPerformancePotential(),
      limitations: this.identifyPerformanceLimitations()
    });
    
    // Decision-making capabilities
    capabilities.set('decision_making', {
      current_level: this.assessDecisionCapability(),
      potential: this.assessDecisionPotential(),
      limitations: this.identifyDecisionLimitations()
    });
    
    // Adaptation capabilities
    capabilities.set('adaptation', {
      current_level: this.assessAdaptationCapability(),
      potential: this.assessAdaptationPotential(),
      limitations: this.identifyAdaptationLimitations()
    });
    
    // Learning capabilities
    capabilities.set('learning', {
      current_level: this.assessLearningCapability(),
      potential: this.assessLearningPotential(),
      limitations: this.identifyLearningLimitations()
    });
    
    return Object.fromEntries(capabilities);
  }

  /**
   * üìä Perform SWOT analysis
   */
  async performSWOTAnalysis() {
    const swot = {
      strengths: [],
      weaknesses: [],
      opportunities: [],
      threats: []
    };
    
    // Analyze performance for strengths/weaknesses
    const performanceAnalysis = await this.analyzePerformance();
    if (performanceAnalysis.trends) {
      for (const [metric, trend] of Object.entries(performanceAnalysis.trends)) {
        if (trend.direction === 'improving' && trend.strength > 0.5) {
          swot.strengths.push(`Strong improvement in ${metric}`);
        } else if (trend.direction === 'declining' && trend.strength > 0.5) {
          swot.weaknesses.push(`Declining performance in ${metric}`);
        }
      }
    }
    
    // Analyze decision quality
    const decisionAnalysis = await this.analyzeDecisions();
    if (decisionAnalysis.success_rate > 0.8) {
      swot.strengths.push('High decision success rate');
    } else if (decisionAnalysis.success_rate < 0.6) {
      swot.weaknesses.push('Low decision success rate');
    }
    
    // Identify opportunities from patterns
    for (const [type, patterns] of this.patternLibrary) {
      const strongPatterns = patterns.filter(p => p.confidence > 0.7 && p.frequency > 3);
      for (const pattern of strongPatterns) {
        if (pattern.opportunity) {
          swot.opportunities.push(pattern.opportunity);
        }
      }
    }
    
    // Identify threats from anomalies
    const performanceAnalysis2 = await this.analyzePerformance();
    if (performanceAnalysis2.anomalies) {
      for (const anomaly of performanceAnalysis2.anomalies) {
        if (anomaly.severity === 'high') {
          swot.threats.push(`Recurring anomaly: ${anomaly.description}`);
        }
      }
    }
    
    return swot;
  }

  /**
   * üí° Generate recommendations
   */
  async generateRecommendations() {
    const recommendations = [];
    
    // Performance recommendations
    const performanceAnalysis = await this.analyzePerformance();
    if (performanceAnalysis.trends) {
      for (const [metric, trend] of Object.entries(performanceAnalysis.trends)) {
        if (trend.direction === 'declining' && trend.strength > 0.6) {
          recommendations.push({
            priority: 'high',
            category: 'performance',
            type: 'improvement',
            target: metric,
            action: `Address declining trend in ${metric}`,
            expected_impact: trend.strength * 0.5,
            effort: 'medium'
          });
        }
      }
    }
    
    // Decision-making recommendations
    const decisionAnalysis = await this.analyzeDecisions();
    if (decisionAnalysis.success_rate < 0.7) {
      recommendations.push({
        priority: 'high',
        category: 'decision_making',
        type: 'process_improvement',
        action: 'Improve decision-making process',
        expected_impact: 0.3,
        effort: 'high'
      });
    }
    
    // Learning recommendations
    if (this.selfModel.learning_progress < 0.5) {
      recommendations.push({
        priority: 'medium',
        category: 'learning',
        type: 'capability_building',
        action: 'Enhance learning mechanisms',
        expected_impact: 0.4,
        effort: 'medium'
      });
    }
    
    // Pattern-based recommendations
    for (const [type, patterns] of this.patternLibrary) {
      const actionablePatterns = patterns.filter(p => p.actionable && p.confidence > 0.6);
      for (const pattern of actionablePatterns) {
        recommendations.push({
          priority: pattern.priority || 'medium',
          category: 'pattern_based',
          type: 'optimization',
          action: pattern.recommendation,
          expected_impact: pattern.impact || 0.3,
          effort: pattern.effort || 'medium'
        });
      }
    }
    
    // Sort by priority and impact
    recommendations.sort((a, b) => {
      const priorityWeight = { high: 3, medium: 2, low: 1 };
      const aScore = priorityWeight[a.priority] * a.expected_impact;
      const bScore = priorityWeight[b.priority] * b.expected_impact;
      return bScore - aScore;
    });
    
    return recommendations.slice(0, 10); // Top 10 recommendations
  }

  /**
   * üéì Extract learning insights
   */
  async extractLearningInsights() {
    const insights = {
      key_learnings: [],
      behavior_changes: [],
      strategy_effectiveness: [],
      capability_development: [],
      future_focus_areas: []
    };
    
    // Extract key learnings from adaptations
    const successfulAdaptations = this.adaptationHistory.filter(a => a.success);
    const adaptationInsights = this.groupAdaptationInsights(successfulAdaptations);
    insights.key_learnings.push(...adaptationInsights);
    
    // Identify behavior changes
    const behaviorChanges = this.identifyBehaviorChanges();
    insights.behavior_changes.push(...behaviorChanges);
    
    // Analyze strategy effectiveness
    const strategyAnalysis = this.analyzeStrategyEffectiveness();
    insights.strategy_effectiveness.push(...strategyAnalysis);
    
    // Assess capability development
    const capabilityDevelopment = this.assessCapabilityDevelopment();
    insights.capability_development.push(...capabilityDevelopment);
    
    // Identify future focus areas
    const focusAreas = this.identifyFutureFocusAreas();
    insights.future_focus_areas.push(...focusAreas);
    
    return insights;
  }

  /**
   * üîÑ Update self-model
   */
  async updateSelfModel(critique) {
    // Update strengths and weaknesses
    this.selfModel.strengths = critique.swot_analysis.strengths;
    this.selfModel.weaknesses = critique.swot_analysis.weaknesses;
    this.selfModel.opportunities = critique.swot_analysis.opportunities;
    this.selfModel.threats = critique.swot_analysis.threats;
    
    // Update capabilities
    if (critique.capability_assessment) {
      for (const [capability, assessment] of Object.entries(critique.capability_assessment)) {
        this.selfModel.capabilities.set(capability, assessment.current_level);
        this.selfModel.limitations.set(capability, assessment.limitations);
      }
    }
    
    // Update learning progress
    const successfulRecommendations = critique.recommendations.filter(r => r.applied && r.success);
    if (successfulRecommendations.length > 0) {
      const improvementRate = successfulRecommendations.length / critique.recommendations.length;
      this.selfModel.learning_progress = Math.min(1, this.selfModel.learning_progress + improvementRate * this.config.learning_rate);
    }
    
    this.emit('self_model_updated', this.selfModel);
  }

  /**
   * ‚ö° Apply immediate improvements
   */
  async applyImmediateImprovements(recommendations) {
    const immediateRecommendations = recommendations.filter(r => 
      r.priority === 'high' && r.effort === 'low'
    );
    
    for (const recommendation of immediateRecommendations) {
      try {
        await this.applyRecommendation(recommendation);
        recommendation.applied = true;
        recommendation.applied_at = new Date();
        
        this.emit('improvement_applied', recommendation);
        console.log(`‚úÖ Applied immediate improvement: ${recommendation.action}`);
        
      } catch (error) {
        console.error(`‚ùå Failed to apply improvement: ${recommendation.action}`, error);
        recommendation.applied = false;
        recommendation.error = error.message;
      }
    }
  }

  /**
   * üîß Apply recommendation
   */
  async applyRecommendation(recommendation) {
    // In a real implementation, this would actually apply the improvement
    // For now, we'll simulate the application
    
    console.log(`üîß Applying recommendation: ${recommendation.action}`);
    
    // Simulate application time
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Record the adaptation
    this.recordAdaptation({
      trigger: 'self_critique_recommendation',
      adaptation: recommendation,
      expected_improvement: recommendation.expected_impact,
      actual_improvement: recommendation.expected_impact * 0.8, // Slightly less than expected
      success: true,
      side_effects: []
    });
    
    return true;
  }

  /**
   * ‚è∞ Start periodic critique
   */
  startPeriodicCritique() {
    const intervalMs = this.config.critique_interval_hours * 60 * 60 * 1000;
    
    this.critiqueTimer = setInterval(async () => {
      try {
        await this.performSelfCritique();
      } catch (error) {
        console.error('‚ùå Periodic self-critique failed:', error);
      }
    }, intervalMs);
    
    console.log(`üïê Periodic self-critique started (interval: ${this.config.critique_interval_hours}h)`);
  }

  /**
   * üîç Start pattern analysis
   */
  startPatternAnalysis() {
    const intervalMs = 60 * 60 * 1000; // Every hour
    
    this.patternAnalysisTimer = setInterval(async () => {
      try {
        await this.analyzePatterns();
      } catch (error) {
        console.error('‚ùå Pattern analysis failed:', error);
      }
    }, intervalMs);
    
    console.log('üîç Pattern analysis started (interval: 1h)');
  }

  /**
   * üìÇ Load historical data
   */
  async loadHistoricalData() {
    try {
      const dataPath = path.join(__dirname, '../../data/self-critique');
      
      if (fs.existsSync(dataPath)) {
        // Load performance history
        const performancePath = path.join(dataPath, 'performance.json');
        if (fs.existsSync(performancePath)) {
          const data = JSON.parse(fs.readFileSync(performancePath, 'utf8'));
          this.performanceHistory = data.map(entry => ({
            ...entry,
            timestamp: new Date(entry.timestamp)
          }));
        }
        
        // Load decision history
        const decisionPath = path.join(dataPath, 'decisions.json');
        if (fs.existsSync(decisionPath)) {
          const data = JSON.parse(fs.readFileSync(decisionPath, 'utf8'));
          this.decisionHistory = data.map(entry => ({
            ...entry,
            timestamp: new Date(entry.timestamp)
          }));
        }
        
        // Load adaptation history
        const adaptationPath = path.join(dataPath, 'adaptations.json');
        if (fs.existsSync(adaptationPath)) {
          const data = JSON.parse(fs.readFileSync(adaptationPath, 'utf8'));
          this.adaptationHistory = data.map(entry => ({
            ...entry,
            timestamp: new Date(entry.timestamp)
          }));
        }
        
        console.log('üìÇ Historical data loaded');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not load historical data:', error.message);
    }
  }

  /**
   * üß† Initialize self-model
   */
  async initializeSelfModel() {
    // Initialize with default values
    this.selfModel = {
      strengths: ['Continuous learning capability', 'Adaptive behavior'],
      weaknesses: ['Limited historical data', 'Initial uncertainty'],
      opportunities: ['Pattern recognition', 'Strategy optimization'],
      threats: ['Performance degradation', 'Decision quality decline'],
      capabilities: new Map([
        ['performance', 0.7],
        ['decision_making', 0.6],
        ['adaptation', 0.8],
        ['learning', 0.5]
      ]),
      limitations: new Map([
        ['performance', ['Resource constraints']],
        ['decision_making', ['Incomplete context']],
        ['adaptation', ['Conservative approach']],
        ['learning', ['Data sparsity']]
      ]),
      learning_progress: 0.1
    };
    
    console.log('üß† Self-model initialized');
  }

  /**
   * üíæ Store critique
   */
  async storeCritique(critique) {
    try {
      const dataPath = path.join(__dirname, '../../data/self-critique');
      
      if (!fs.existsSync(dataPath)) {
        fs.mkdirSync(dataPath, { recursive: true });
      }
      
      const critiquePath = path.join(dataPath, 'critiques.json');
      let critiques = [];
      
      if (fs.existsSync(critiquePath)) {
        critiques = JSON.parse(fs.readFileSync(critiquePath, 'utf8'));
      }
      
      critiques.push(critique);
      
      // Keep only recent critiques
      critiques = critiques.slice(-100); // Last 100 critiques
      
      fs.writeFileSync(critiquePath, JSON.stringify(critiques, null, 2));
      
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not store critique:', error.message);
    }
  }

  // Helper methods for analysis
  calculateTrends(recent, older) {
    const trends = {};
    
    if (recent.length === 0 || older.length === 0) return trends;
    
    const metrics = ['ors', 'task_success_rate', 'avg_response_time', 'error_rate'];
    
    for (const metric of metrics) {
      const recentAvg = recent.reduce((sum, entry) => sum + (entry[metric] || 0), 0) / recent.length;
      const olderAvg = older.reduce((sum, entry) => sum + (entry[metric] || 0), 0) / older.length;
      
      const change = (recentAvg - olderAvg) / olderAvg;
      const strength = Math.abs(change);
      
      trends[metric] = {
        direction: change > 0.1 ? 'improving' : change < -0.1 ? 'declining' : 'stable',
        strength: Math.min(1, strength),
        change_percent: change * 100
      };
    }
    
    return trends;
  }

  detectAnomalies(data) {
    const anomalies = [];
    
    if (data.length < 10) return anomalies;
    
    // Simple anomaly detection using standard deviation
    const metrics = ['ors', 'task_success_rate', 'avg_response_time', 'error_rate'];
    
    for (const metric of metrics) {
      const values = data.map(entry => entry[metric] || 0).filter(v => v > 0);
      if (values.length < 5) continue;
      
      const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
      const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
      const stdDev = Math.sqrt(variance);
      
      for (let i = 0; i < data.length; i++) {
        const value = data[i][metric] || 0;
        if (Math.abs(value - mean) > 2 * stdDev) {
          anomalies.push({
            timestamp: data[i].timestamp,
            metric,
            value,
            expected: mean,
            deviation: Math.abs(value - mean) / stdDev,
            severity: Math.abs(value - mean) > 3 * stdDev ? 'high' : 'medium',
            description: `Anomalous ${metric}: ${value.toFixed(2)} (expected: ${mean.toFixed(2)})`
          });
        }
      }
    }
    
    return anomalies;
  }

  findCorrelations(data) {
    // Simplified correlation analysis
    const correlations = [];
    
    if (data.length < 10) return correlations;
    
    const metrics = ['ors', 'task_success_rate', 'avg_response_time', 'error_rate'];
    
    for (let i = 0; i < metrics.length; i++) {
      for (let j = i + 1; j < metrics.length; j++) {
        const metric1 = metrics[i];
        const metric2 = metrics[j];
        
        const values1 = data.map(entry => entry[metric1] || 0);
        const values2 = data.map(entry => entry[metric2] || 0);
        
        const correlation = this.calculateCorrelation(values1, values2);
        
        if (Math.abs(correlation) > 0.5) {
          correlations.push({
            metric1,
            metric2,
            correlation,
            strength: Math.abs(correlation),
            type: correlation > 0 ? 'positive' : 'negative'
          });
        }
      }
    }
    
    return correlations;
  }

  calculateCorrelation(x, y) {
    const n = x.length;
    if (n === 0) return 0;
    
    const sumX = x.reduce((sum, val) => sum + val, 0);
    const sumY = y.reduce((sum, val) => sum + val, 0);
    const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);
    const sumX2 = x.reduce((sum, val) => sum + val * val, 0);
    const sumY2 = y.reduce((sum, val) => sum + val * val, 0);
    
    const numerator = n * sumXY - sumX * sumY;
    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
    
    return denominator === 0 ? 0 : numerator / denominator;
  }

  // Placeholder methods for full implementation
  calculateEfficiencyMetrics(data) { return { overall: 0.8 }; }
  calculateHealthIndicators(data) { return { health_score: 0.85 }; }
  calculateConfidenceAccuracy(data) { return 0.75; }
  identifyDecisionPatterns(data) { return []; }
  analyzeContextSensitivity(data) { return { sensitivity: 0.6 }; }
  calculatePredictionAccuracy(data) { return 0.7; }
  identifyDecisionImprovementAreas(data) { return []; }
  calculateImprovementMagnitude(data) { return 0.3; }
  calculateSideEffectFrequency(data) { return 0.1; }
  identifyAdaptationPatterns(data) { return []; }
  analyzeTriggerEffectiveness(data) { return { effectiveness: 0.8 }; }
  calculateLearningVelocity(data) { return 0.05; }
  findPerformancePatterns() { return []; }
  findDecisionPatterns() { return []; }
  findTemporalPatterns() { return []; }
  findContextualPatterns() { return []; }
  findResourcePatterns() { return []; }
  findErrorPatterns() { return []; }
  assessPerformanceCapability() { return 0.7; }
  assessPerformancePotential() { return 0.9; }
  identifyPerformanceLimitations() { return ['Resource constraints']; }
  assessDecisionCapability() { return 0.6; }
  assessDecisionPotential() { return 0.8; }
  identifyDecisionLimitations() { return ['Incomplete context']; }
  assessAdaptationCapability() { return 0.8; }
  assessAdaptationPotential() { return 0.9; }
  identifyAdaptationLimitations() { return ['Conservative approach']; }
  assessLearningCapability() { return 0.5; }
  assessLearningPotential() { return 0.8; }
  identifyLearningLimitations() { return ['Data sparsity']; }
  groupAdaptationInsights(adaptations) { return []; }
  identifyBehaviorChanges() { return []; }
  analyzeStrategyEffectiveness() { return []; }
  assessCapabilityDevelopment() { return []; }
  identifyFutureFocusAreas() { return []; }
}

module.exports = SelfCritiqueEngine;
